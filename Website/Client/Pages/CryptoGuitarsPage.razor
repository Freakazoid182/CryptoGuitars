@page "/crypto-guitars"
@using MetaMask.Blazor
@using MetaMask.Blazor.Enums
@using Nethereum.ABI.Model
@using Nethereum.Web3
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.Extensions.Configuration
@using CryptoGuitars.Shared.DTOs
@using CryptoGuitars.Shared.Enums
@inject IConfiguration Configuration
@inject MetaMaskService MetaMaskService
@inject IHttpClientFactory HttpClientFactory
@inject IWeb3 Web3Service

<PageTitle>Crypto Guitars 🎸</PageTitle>

@if(CryptoGuitarTokenDTOs != null)
{
    <MudContainer>
        <MudGrid Spacing="5">
            @if(!string.IsNullOrEmpty(SelectedAddress))
            {
                <MudPaper Class="d-inline-flex pa-4 ma-2" Height="230px" Width="180px">
                    <MudButton Color="Color.Tertiary" Variant="Variant.Filled" @onclick="Mint">Mint a new Guitar!</MudButton>
                </MudPaper>
            }
            else if(HasMetaMask == true)
            {
                <MudPaper Class="d-inline-flex pa-4 ma-2" Height="230px" Width="180px">
                    <MudButton Color="Color.Tertiary" Variant="Variant.Filled" @onclick="ConnectMetaMask">Connect with Metamask to start minting!</MudButton>
                </MudPaper>
            }
            @foreach (var item in CryptoGuitarTokenDTOs)
            {
                <MudPaper Class="ma-2" Height="230px" Width="180px">
                    <MudImage Src="@item?.MetaData?.Image" Alt="@item?.MetaData?.Description" Class="rounded-lg ma-1"/>
                    <MudText ><b># @item?.Id</b></MudText>
                    <MudText Typo="Typo.caption">Owned By @item?.Owner?.Substring(0, 10)</MudText>
                </MudPaper>
            }
        </MudGrid>
    </MudContainer>
}

@code {

    IEnumerable<CryptoGuitarTokenDTO>? CryptoGuitarTokenDTOs;
    HttpClient? ServerHttpClient;
    bool? HasMetaMask;
    string? SelectedAddress;
    string? SelectedChain;

    string? RpcResult;
    Chain? Chain;

    protected override async Task OnInitializedAsync()
    {
        ServerHttpClient = HttpClientFactory.CreateClient("server");

        //Subscribe to events
        MetaMaskService.AccountChangedEvent += MetaMaskService_AccountChangedEvent;
        MetaMaskService.ChainChangedEvent += MetaMaskService_ChainChangedEvent;

        HasMetaMask = await MetaMaskService.HasMetaMask();
        if (HasMetaMask == true)
            await MetaMaskService.ListenToEvents();

        bool isSiteConnected = await MetaMaskService.IsSiteConnected();
        if (isSiteConnected)
        {
            await GetSelectedAddress();
            await GetSelectedNetwork();
        }

        await LoadTokens();
    }

    private async Task MetaMaskService_ChainChangedEvent((long, Chain) arg)
    {
        await GetSelectedNetwork();
        StateHasChanged();
    }

    private async Task MetaMaskService_AccountChangedEvent(string arg)
    {
        await GetSelectedAddress();
        StateHasChanged();
    }

    private async Task ConnectMetaMask()
    {
        await MetaMaskService.ConnectMetaMask();
        await GetSelectedAddress();
    }

    private async Task GetSelectedAddress()
    {
        SelectedAddress = await MetaMaskService.GetSelectedAddress();
        Console.WriteLine($"Address: {SelectedAddress}");
    }

    private async Task GetSelectedNetwork()
    {
        var chainInfo = await MetaMaskService.GetSelectedChain();
        Chain = chainInfo.chain;

        SelectedChain = $"ChainID: {chainInfo.chainId}, Name: {chainInfo.chain.ToString()}";
        Console.WriteLine($"ChainID: {chainInfo.chainId}");
    }

    private async Task GetBalance()
    {
        var address = await MetaMaskService.GetSelectedAddress();
        var result = await MetaMaskService.GetBalance(address);
        RpcResult = $"Balance result: {result / 1e18} eth";
    }

    private void Dispose()
    {
        MetaMaskService.AccountChangedEvent -= MetaMaskService_AccountChangedEvent;
        MetaMaskService.ChainChangedEvent -= MetaMaskService_ChainChangedEvent;
    }

    private async Task LoadTokens()
    {
        var totalSupply = await ServerHttpClient!.GetFromJsonAsync<int>("api/v1/crypto-guitar-contract/total-supply");

        // TODO: Add paging
        var param = new Dictionary<string, string>()
        {
            { "offset", "0" },
            { "limit", (totalSupply < 10 ? totalSupply : 10).ToString() },
            { "sort", Sort.Desc.ToString() }
        };

        var pathAndQuery = QueryHelpers.AddQueryString("/api/v1/crypto-guitars-tokens", param);
        var getCryptoGuitarTokensResult = await ServerHttpClient!.GetFromJsonAsync<GetCryptoGuitarTokensDTO>(pathAndQuery);

        CryptoGuitarTokenDTOs = getCryptoGuitarTokensResult?.Data;
    }

    private async void Mint()
    {
        var contractAddress = Configuration["Contracts:CryptoGuitarsNFT:Address"];
        string serverUrl = Configuration["Server:BaseUrl"];
        var serverHttpClient = ServerHttpClient ?? throw new NullReferenceException(nameof(ServerHttpClient));

        // This is slightly weak and the tokenId should probably be generated by the contract
        var tokenIdAndIndex = await serverHttpClient.GetFromJsonAsync<int>("api/v1/crypto-guitar-contract/total-supply");
        var receipt = await MetaMaskService.SendTransactionAndWaitForReceipt
        (
            Web3Service.Client,
            "mint",
            contractAddress,
            Web3.Convert.ToWei(0.05),
            new List<Parameter>
            {
                new Parameter("address", "_to"),
                new Parameter("uint256", "_tokenId"),
                new Parameter("string", "_uri")
            }.ToArray(),
            SelectedAddress ?? throw new ArgumentNullException(nameof(SelectedAddress)),
            tokenIdAndIndex,
            $"{serverUrl}/metadata/CryptoGuitars-{(int)tokenIdAndIndex}-metadata.json"
        );

        await LoadTokens();

        StateHasChanged();
    }
}
